# Типы данных

## Числовые типы

1. **int** — целые числа
2. **float** — числа с плавающей запятой (десятичные)
3. **complex** — комплексные числа

## Строки (str)

Строки в Python являются последовательностями символов и заключаются в одинарные или двойные кавычки.


## Последовательности

1. **list** — список
2. **tuple** — кортеж
3. **range** — диапазон

## Множества
1. **set** — множество
   - Неупорядоченная коллекция уникальных элементов.
   - Пример: `{1, 2, 3, 'apple'}`
2. **frozenset** — замороженное множество
   - Неизменяемая версия множества.
   - Пример: `frozenset([1, 2, 3])`

### Словари (dict)

Словарь представляет собой неупорядоченную коллекцию пар "ключ-значение".
- Пример: `{'name': 'Alice', 'age': 25, 'is_student': True}`

### Булевы значения (bool)
Булевы значения используются для представления истинности логических выражений.

### Специальные типы данных

1. **None** — специальное значение, которое обозначает отсутствие данных или пустоту.
2. **bytes** — тип данных для хранения последовательности байтов.

## Изменяемые и не изменяемые типы данных в Python

В Python данные могут быть либо изменяемыми, либо не изменяемыми. Это различие важно при работе с переменными, так как оно определяет, как данные могут быть изменены в памяти.

### Неизменяемые типы данных (Immutable)

Неизменяемые типы данных — это типы данных, которые не могут быть изменены после их создания. Когда вы пытаетесь изменить значение неизменяемого объекта, создается новый объект в памяти.

### Примеры неизменяемых типов данных:

1. **int** — целые числа
   - Пример: `x = 5`
2. **float** — числа с плавающей запятой
   - Пример: `y = 3.14`
3. **str** — строки
   - Пример: `s = "hello"`
4. **tuple** — кортежи
   - Пример: `t = (1, 2, 3)`
5. **frozenset** — замороженные множества
   - Пример: `frozen_set = frozenset([1, 2, 3])`
6. **bytes** — байтовые строки
   - Пример: `b = b'hello'`

### Особенности:
- Изменить отдельные элементы или структуру объекта, например, строку или кортеж, нельзя.
- При изменении создается новый объект.

### Изменяемые типы данных (Mutable)

Изменяемые типы данных — это типы данных, которые могут быть изменены после их создания. При изменении объекта данные обновляются в памяти, и тот же объект остаётся.

### Примеры изменяемых типов данных:

1. **list** — списки
   - Пример: `lst = [1, 2, 3]`
2. **set** — множества
   - Пример: `s = {1, 2, 3}`
3. **dict** — словари
   - Пример: `d = {'name': 'Alice', 'age': 25}`



```python
a: int = 3
print(f'id_1: {id(a)}')
a += 1
print(f'id_2: {id(a)}')

lst: list[int] = [3, 5, 2, 5]
print(f'id_3: {id(lst)}')
lst += [43]
print(f'id_4: {id(lst)}')
```

```python
int_1: 4350962400
int_2: 4350962432
int_3: 4333614848
int_4: 4333614848
```

# Коллекции

## 1. Списки (list)
Списки — это упорядоченные, изменяемые коллекции. Они могут содержать элементы разных типов и поддерживают дублирование.

### Методы:
- `append(x)` — добавляет элемент `x` в конец списка.
- `insert(i, x)` — вставляет элемент `x` на позицию `i`.
- `remove(x)` — удаляет первое вхождение элемента `x`.
- `pop([i])` — удаляет и возвращает элемент по индексу `i`.
- `sort()` — сортирует элементы списка.
- `reverse()` — переворачивает элементы списка.
- `extend(iterable)` — добавляет все элементы из другого итерируемого объекта в конец списка.


## 2. Кортежи (tuple)
Кортежи — это упорядоченные, неизменяемые коллекции. Элементы кортежа могут быть разных типов.

### Методы:
- `count(x)` — возвращает количество вхождений элемента x.
- `index(x)` — возвращает индекс первого вхождения элемента x.


## 3. Множества (set)
Множества — это неупорядоченные коллекции уникальных элементов.
### Методы:
- `add(x)` — добавляет элемент x в множество.
- `remove(x)` — удаляет элемент x из множества.
- `discard(x)` — удаляет элемент x из множества, если он существует.
- `pop()` — удаляет и возвращает произвольный элемент.
- `union(other)` — возвращает объединение двух множеств.
- `intersection(other)` — возвращает пересечение двух множеств.
- `difference(other)` — возвращает разницу между множествами.
- `clear()` — удаляет все элементы из множества.

## 4. Словари (dict)
Словари — это неупорядоченные коллекции пар "ключ-значение".

### Методы:
- `get(key)` — возвращает значение для ключа key или None, если ключ не найден.
- `keys()` — возвращает представление всех ключей словаря.
- `values()` — возвращает представление всех значений словаря.
- `items()` — возвращает представление всех пар ключ-значение.
- `update(other)` — обновляет словарь, добавляя элементы из другого словаря.
- `pop(key)` — удаляет и возвращает значение по ключу key.
- `popitem()` — удаляет и возвращает произвольную пару ключ-значение.
- `clear()` — удаляет все элементы из словаря.

# Функции

Функции в Python — это блоки кода, которые выполняют определённую задачу и могут быть повторно использованы в программе. Они позволяют структурировать код, повышать его читаемость и уменьшать дублирование.

---

### 1. Определение и вызов функций

### Определение функции:
Функция определяется с помощью ключевого слова `def`, за которым следует имя функции, круглые скобки (с возможными аргументами) и двоеточие.

### Синтаксис:
```python
def имя_функции(параметры):
    """Документация функции (необязательно)"""
    тело_функции
    return значение  # (необязательно)
```

### 2. Аргументы функций
### Виды аргументов:
- Обязательные: передаются в функцию при её вызове.
- Необязательные (со значением по умолчанию): имеют заданное значение, если их не передали.
- Произвольное количество позиционных аргументов: собираются в кортеж с помощью *args.
- Произвольное количество именованных аргументов: собираются в словарь с помощью **kwargs.


```python
def example(a, b=10, *args, **kwargs):
    print(f"a = {a}, b = {b}")
    print(f"args = {args}")
    print(f"kwargs = {kwargs}")

example(1, 2, 3, 4, key1="value1", key2="value2")
# a = 1, b = 2
# args = (3, 4)
# kwargs = {'key1': 'value1', 'key2': 'value2'}
```

### 3. Декораторы

Декораторы — это функции, которые принимают другую функцию в качестве аргумента и возвращают новую функцию, расширяя её поведение.

### Пример:
```python
def decorator(func):
    def wrapper(*args, **kwargs):
        print("Выполнение функции...")
        result = func(*args, **kwargs)
        print("Функция выполнена.")
        return result
    return wrapper

@decorator
def say_hello():
    print("Привет!")

say_hello()
# Выполнение функции...
# Привет!
# Функция выполнена.
```


### 4. Функции высшего порядка
Функции высшего порядка принимают другие функции как аргументы или возвращают их.

### Примеры:
- `map(func, iterable)`: применяет функцию к каждому элементу итерируемого объекта.
- `filter(func, iterable)`: возвращает элементы, которые удовлетворяют условию.
- `reduce(func, iterable)` (из functools): сворачивает последовательность в одно значение.
```python
from functools import reduce

nums = [1, 2, 3, 4]
print(list(map(lambda x: x**2, nums)))  # [1, 4, 9, 16]
print(list(filter(lambda x: x % 2 == 0, nums)))  # [2, 4]
print(reduce(lambda x, y: x + y, nums))  # 10
```

### 5. Встроенные функции
Python предоставляет множество встроенных функций, таких как:

- `len()`: длина объекта.
- `max()`: максимум из элементов.
- `min()`: минимум из элементов.
- `sum()`: сумма элементов.
- `zip()`: объединение последовательностей.
- `sorted()`: сортировка последовательности.
- `all()` / `any()`: проверка условий для всех / некоторых элементов.



# Генераторы

**Генераторы** — это специальный вид функций, которые позволяют создавать итераторы. Они используют ключевое слово `yield` для сохранения состояния между вызовами. Генераторы удобны для работы с большими данными, так как они возвращают элементы по одному, вместо того чтобы загружать все элементы в память.

---

## 1. Особенность генератора

В отличие от обычной функции, которая завершает выполнение после вызова `return`, генератор «запоминает» своё состояние благодаря `yield`. При следующем вызове генератора выполнение продолжается с того места, где оно было прервано.

### Пример:
```python
def simple_generator():
    yield 1
    yield 2
    yield 3

gen = simple_generator()
print(next(gen))  # 1
print(next(gen))  # 2
print(next(gen))  # 3
```

# 2. Основы работы генератора
- **Создание**: генератор создаётся как обычная функция с использованием yield вместо return.
- **Итерация**: каждый вызов next() возвращает следующее значение, генерируемое yield.
- **Сохранение состояния**: после выполнения yield генератор запоминает своё текущее состояние (значения всех переменных и инструкцию, которая будет выполнена при следующем вызове).

# 3. Преимущества генераторов
- _Эффективное использование памяти:_ генераторы создают значения по мере необходимости, а не хранят все значения в памяти.
- _Ленивые вычисления:_ генераторы вычисляют значения только тогда, когда они запрашиваются.
- _Удобство для работы с большими данными:_ генераторы идеально подходят для обработки потоков данных или огромных последовательностей.

# 4.Генераторы и выражения-генераторы
### Генераторные функции:
Генераторы создаются с помощью функций с использованием yield.

### Выражения-генераторы:
Это краткий способ создания генераторов с использованием круглых скобок.

### Пример:
```python
gen_expr = (x**2 for x in range(5))
print(next(gen_expr))  # 0
print(next(gen_expr))  # 1
```


????








# Объектно-ориентированное программирование (ООП) в Python

**Объектно-ориентированное программирование (ООП)** — это парадигма программирования, основанная на концепции объектов, которые объединяют данные и методы для работы с этими данными. Python поддерживает ООП и позволяет создавать мощные и удобные для сопровождения программы.

---

## Основные принципы ООП

1. **Абстракция**: выделение важных характеристик объекта, скрывая его внутренние детали.
2. **Инкапсуляция**: объединение данных и методов в классе, управление доступом к ним.
3. **Наследование**: возможность создавать новый класс на основе существующего.
4. **Полиморфизм**: способность объектов разных классов обрабатывать вызовы одноимённых методов по-своему.

---

## Ключевые понятия в ООП

### 1. Класс
Класс — это шаблон или чертёж для создания объектов.

#### Синтаксис:
```python
class MyClass:
    pass
```

### 2. Объект
Объект — это экземпляр класса.

#### Создание объекта:
```python
obj = MyClass()
```

---

## Ключевые элементы класса

### 1. Атрибуты
Атрибуты — это переменные, которые описывают состояние объекта.

### 2. Методы
Методы — это функции, определённые внутри класса.

---

## Специальные методы

### 1. `__init__`
Инициализатор класса, который вызывается при создании объекта.

### 2. `__str__`
Возвращает строковое представление объекта.

### 3. `__repr__`
Возвращает строку, описывающую объект (для разработчиков).

---

## Инкапсуляция

### Уровни доступа к атрибутам:
- **Публичный (`public`)**: доступен из любого места.
  ```python
  self.attribute
  ```
- **Защищённый (`protected`)**: доступен в классе и его потомках (договорённость, начинается с `_`).
  ```python
  self._attribute
  ```
- **Приватный (`private`)**: доступен только в классе (начинается с `__`).
  ```python
  self.__attribute
  ```

#### Пример:
```python
class Account:
    def __init__(self, balance):
        self.__balance = balance  # Приватный атрибут

    def get_balance(self):
        return self.__balance
```

---

## Наследование

Позволяет создавать новый класс, наследуя свойства и методы существующего.

#### Пример:
```python
class Animal:
    def speak(self):
        return "I make a sound"

class Dog(Animal):
    def speak(self):
        return "Woof!"
```

#### Проверка наследования:
```python
dog = Dog()
print(dog.speak())  # "Woof!"
```

---

## Полиморфизм

Позволяет объектам разных классов иметь одноимённые методы с разной реализацией.

#### Пример:
```python
class Bird:
    def speak(self):
        return "Chirp!"

class Cat:
    def speak(self):
        return "Meow!"

animals = [Bird(), Cat()]
for animal in animals:
    print(animal.speak())
```

---

## Множественное наследование

Класс может наследовать несколько других классов.

#### Пример:
```python
class A:
    def method(self):
        return "Method from A"

class B:
    def method(self):
        return "Method from B"

class C(A, B):
    pass

c = C()
print(c.method())  # "Method from A" (по порядку MRO)
```

---

## Абстракция

Абстрактный класс — это класс, который нельзя создать напрямую, а его методы должны быть реализованы в подклассах.

#### Пример:
```python
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3.14 * self.radius ** 2
```

---

## Методы класса и статические методы

### 1. Метод класса (`@classmethod`)
Метод, который получает доступ к самому классу.

#### Пример:
```python
class MyClass:
    count = 0

    @classmethod
    def increment_count(cls):
        cls.count += 1
```

### 2. Статический метод (`@staticmethod`)
Метод, который не зависит от класса и объекта.

#### Пример:
```python
class Math:
    @staticmethod
    def add(a, b):
        return a + b
```

---

## Преимущества ООП

1. Упрощает управление сложным кодом.
2. Способствует повторному использованию кода через наследование.
3. Улучшает читаемость и поддерживаемость программ.

---

## Недостатки ООП

1. Увеличение сложности при небольших проектах.
2. Меньшая скорость выполнения из-за уровня абстракции.

# Mоки

# Моки в Python

**Моки** (от англ. *mock*) — это объекты, которые используются в тестировании для замены реальных объектов или функций. Они позволяют изолировать тестируемый код от внешних зависимостей, таких как базы данных, сетевые запросы или сторонние библиотеки.

Моки часто применяются в **модульном тестировании**, чтобы:
- проверить взаимодействие между компонентами,
- эмулировать поведение внешних систем,
- контролировать результаты вызовов.

---

## 1. Инструменты для работы с моками в Python

### 1.1 Модуль `unittest.mock`
Python предоставляет встроенный модуль `unittest.mock`, который содержит классы и функции для создания моков:
- `Mock` — основной класс для создания мока.
- `patch` — декоратор или контекстный менеджер для замены объектов на моки.
- `MagicMock` — расширенная версия `Mock` с поддержкой магических методов.

### 1.2 Установка (если используется сторонняя библиотека `pytest-mock`)
Для работы с модулями, такими как `pytest-mock`, можно установить библиотеку:
```bash
pip install pytest-mock
```

---

## 2. Создание и использование Mock

### 2.1 Создание мока
```python
from unittest.mock import Mock

# Создание мока
mock = Mock()

# Настройка возвращаемого значения
mock.method.return_value = "Hello, Mock!"

# Вызов метода
result = mock.method()
print(result)  # "Hello, Mock!"
```

### 2.2 Проверка вызовов
Моки позволяют проверить, вызывался ли метод и с какими аргументами.
```python
mock.method("arg1", "arg2")

# Проверка вызова
mock.method.assert_called_once_with("arg1", "arg2")
```

---

## 3. Декоратор `patch`

### 3.1 Замена объекта
Декоратор `patch` используется для замены реального объекта на мок во время выполнения теста.
```python
from unittest.mock import patch

@patch("module.Class.method")
def test_mock_method(mock_method):
    # Настройка возвращаемого значения
    mock_method.return_value = "Mocked Result"
    
    # Вызов замещаемого метода
    result = module.Class.method()
    assert result == "Mocked Result"
```

### 3.2 Контекстный менеджер `patch`
`patch` можно использовать как контекстный менеджер.
```python
with patch("module.Class.method") as mock_method:
    mock_method.return_value = "Mocked Result"
    assert module.Class.method() == "Mocked Result"
```

---

## 4. `MagicMock`

Класс `MagicMock` предоставляет поддержку магических методов, таких как `__getitem__`, `__setitem__`, `__call__`, и других.
```python
from unittest.mock import MagicMock

mock = MagicMock()

# Настройка магического метода
mock.__getitem__.return_value = "Mocked Item"
print(mock["key"])  # "Mocked Item"
```

---

## 5. Использование в реальных тестах

### 5.1 Мок сетевого запроса
```python
import requests
from unittest.mock import patch

def fetch_data(url):
    response = requests.get(url)
    return response.json()

@patch("requests.get")
def test_fetch_data(mock_get):
    mock_get.return_value.json.return_value = {"key": "value"}
    
    result = fetch_data("http://example.com")
    assert result == {"key": "value"}
```

### 5.2 Мок базы данных
```python
from unittest.mock import Mock

# Пример работы с базой данных
class Database:
    def get_user(self, user_id):
        # Обращение к реальной базе данных
        pass

def test_get_user():
    db = Mock()
    db.get_user.return_value = {"id": 1, "name": "John"}
    
    result = db.get_user(1)
    assert result == {"id": 1, "name": "John"}
```

---

## 6. Сравнение `Mock` и `MagicMock`

| **Mock**            | **MagicMock**               |
|----------------------|-----------------------------|
| Подходит для большинства случаев. | Расширенный функционал для магических методов. |
| Нет поддержки методов вроде `__getitem__`, `__call__`. | Поддерживает магические методы. |
| Используется в базовых сценариях. | Используется для сложных объектов. |

---

## 7. Преимущества использования моков

1. **Изоляция тестов:** Код тестируется независимо от внешних систем.
2. **Управление зависимостями:** Можно контролировать поведение вызовов.
3. **Ускорение тестов:** Моки позволяют избежать обращения к медленным ресурсам (например, к базе данных или API).
4. **Повышение надёжности:** Тесты не зависят от внешних факторов, таких как сетевые сбои.

---

## 8. Лимитации моков

1. **Тестирование реального поведения:** Моки не проверяют работу с реальными объектами.
2. **Сложность настройки:** В сложных системах моки могут потребовать детальной конфигурации.
3. **Зависимость от реализации:** Изменение тестируемого кода может потребовать обновления моков.

---

# Фикстуры и плагины

**Плагины** и **фикстуры** — ключевые концепции в таких фреймворках, как **pytest**, которые делают тестирование гибким, расширяемым и повторно используемым.

---

## 1. Что такое фикстуры?

**Фикстура** — это функция, которая предоставляет начальную настройку для тестов. Она может подготавливать тестовые данные, открывать соединения, настраивать моки или выполнять любые действия, необходимые перед началом теста. 

Фикстуры помогают:
- **Избежать дублирования кода:** Например, если множество тестов использует одинаковые данные или настройки.
- **Сделать тесты более читаемыми и структурированными.**

### Пример фикстуры в `pytest`
```python
import pytest

@pytest.fixture
def sample_data():
    return {"id": 1, "name": "Test"}

def test_sample(sample_data):
    assert sample_data["id"] == 1
    assert sample_data["name"] == "Test"
```

### Характеристики фикстур:
1. **Повторное использование:** Одна фикстура может быть использована в нескольких тестах.
2. **Автоматическое управление ресурсами:** Например, фикстура может выполнять действия до и после теста.
3. **Иерархия фикстур:** Одни фикстуры могут зависеть от других.

---

## 2. Использование фикстур

### 2.1 Передача фикстуры как аргумента
Фикстуры передаются в тестовые функции как аргументы. `pytest` автоматически определяет, какие фикстуры нужны, и вызывает их.

```python
@pytest.fixture
def sample_list():
    return [1, 2, 3]

def test_length(sample_list):
    assert len(sample_list) == 3
```

### 2.2 Уровни фикстур (scope)
Фикстуры могут иметь разные уровни области действия:
- `function` (по умолчанию) — вызывается перед каждым тестом.
- `class` — вызывается один раз на весь класс.
- `module` — вызывается один раз для всех тестов в модуле.
- `session` — вызывается один раз для всей сессии тестирования.

```python
@pytest.fixture(scope="module")
def setup_module():
    return "This is a module-level setup"
```

---

## 3. Что такое плагины?

**Плагины** — это расширения для тестового фреймворка, такие как `pytest`, которые добавляют дополнительный функционал. Они могут предоставлять:
- **Дополнительные фикстуры.**
- **Расширенные команды.**
- **Поддержку интеграции с инструментами (например, для работы с базами данных, мока тестов или отчетов).**

### Примеры популярных плагинов:
1. **`pytest-mock`:** Добавляет поддержку моков из `unittest.mock`.
2. **`pytest-django`:** Для тестирования Django-приложений.
3. **`pytest-cov`:** Генерирует отчеты о покрытии кода.
4. **`pytest-html`:** Генерирует HTML-отчеты о результатах тестирования.

---

## 4. Связь плагинов и фикстур

Многие плагины предоставляют готовые фикстуры, которые можно использовать в тестах. Например:

### Пример с `pytest-django`
Плагин предоставляет фикстуры для работы с базой данных:
```python
@pytest.mark.django_db
def test_with_db():
    # Тесты, которые используют базу данных
    assert MyModel.objects.count() == 0
```

### Пример с `pytest-mock`
Плагин предоставляет фикстуру `mocker` для упрощённой работы с моками.
```python
def test_mock(mocker):
    mock_function = mocker.patch("module.function")
    mock_function.return_value = "Mocked"
    assert module.function() == "Mocked"
```

---

## 5. Создание кастомных фикстур и плагинов

### 5.1 Кастомные фикстуры
Вы можете создавать собственные фикстуры для уникальных нужд.
```python
@pytest.fixture
def custom_setup():
    print("Setting up")
    yield
    print("Tearing down")
```

### 5.2 Кастомные плагины
Создание плагинов позволяет добавить функционал, общий для множества проектов.

#### Шаги для создания плагина:
1. Создайте Python-модуль с функциями.
2. Зарегистрируйте плагин в `setup.py` или `pyproject.toml`.
3. Используйте плагин в тестах.












# Тестирование

Тестирование программного обеспечения (ПО) — это процесс проверки программного продукта для выявления ошибок, соответствия требованиям и обеспечения качества. Основные цели тестирования: повышение надёжности ПО, предотвращение дефектов и минимизация рисков.

---

## 1. Виды тестирования

Тестирование делится на категории по различным критериям, таким как уровень тестирования, цель и способ выполнения. 

### 1.1 Уровни тестирования

#### 1.1.1 Модульное тестирование (Unit Testing)
- Проверка отдельных модулей или функций приложения.
- Обычно пишется разработчиками.
- Использует моки или стабы для изоляции тестируемого модуля.

**Пример:**
```python
def add(a, b):
    return a + b

def test_add():
    assert add(2, 3) == 5
```

#### 1.1.2 Интеграционное тестирование (Integration Testing)
- Проверяет взаимодействие между модулями.
- Цель — убедиться, что модули корректно работают вместе.

**Пример:** Проверка взаимодействия базы данных и логики приложения.

#### 1.1.3 Системное тестирование (System Testing)
- Проверяет систему целиком, включая все её компоненты.
- Обычно выполняется тестировщиками.

#### 1.1.4 Приёмочное тестирование (Acceptance Testing)
- Проверяет, соответствует ли система бизнес-требованиям.
- Проводится с участием заказчиков или конечных пользователей.

---

### 1.2 По целям тестирования

#### 1.2.1 Функциональное тестирование
- Проверяет, что система выполняет свои функции в соответствии с требованиями.

#### 1.2.2 Нефункциональное тестирование
- Проверяет аспекты, не связанные с функциональностью:
  - **Производительность (Performance Testing)**: скорость, устойчивость под нагрузкой.
  - **Надёжность (Reliability Testing)**: устойчивость к сбоям.
  - **Удобство использования (Usability Testing)**: комфортность интерфейса.

#### 1.2.3 Регрессионное тестирование
- Проверяет, что изменения или исправления не нарушили работу других частей системы.

#### 1.2.4 Тестирование безопасности (Security Testing)
- Оценивает защиту системы от атак и утечек данных.

---

### 1.3 По способу выполнения

#### 1.3.1 Ручное тестирование
- Тестировщики вручную проверяют работу приложения.

#### 1.3.2 Автоматизированное тестирование
- Используются инструменты или скрипты для выполнения тестов.

**Инструменты:**
- Selenium (веб-тестирование)
- Pytest (Python)
- JUnit (Java)

---

## 2. Пирамида тестирования

Пирамида тестирования — концепция, описывающая распределение тестов на разных уровнях. Она помогает построить эффективную стратегию тестирования.

### Уровни пирамиды:

#### 2.1 Основание: Модульные тесты (Unit Tests)
- Самый большой слой.
- Покрывает отдельные функции или методы.
- Быстрые, дёшевые и легко поддерживаемые.

#### 2.2 Средний уровень: Интеграционные тесты (Integration Tests)
- Проверяют взаимодействие между компонентами.
- Более медленные и сложные, чем модульные.

#### 2.3 Верхушка: E2E-тесты (End-to-End Tests)
- Проверяют весь процесс, от ввода данных до получения результата.
- Долгие, сложные и дорогие.

### Пример пирамиды:

```
       /\       <- E2E-тесты (10%)
      /  \      
     /    \     <- Интеграционные тесты (20-30%)
    /______\    <- Модульные тесты (60-70%)
```

**Почему это важно?**
- Пирамида помогает оптимизировать затраты на тестирование.
- Упор на модульные тесты позволяет быстро находить ошибки.

---

## 3. Принципы автоматизированного тестирования (AQA)

Автоматизированное тестирование (AQA) основывается на следующих принципах:

### 3.1 SMART-тесты
Каждый тест должен быть:
- **Specific** (Конкретный): Проверять только одну функциональность.
- **Measurable** (Измеримый): Результат теста должен быть однозначным.
- **Achievable** (Достижимый): Не зависящий от внешних факторов.
- **Relevant** (Актуальный): Проверять важные аспекты системы.
- **Time-bound** (Ограниченный по времени): Быстрый в исполнении.

---

### 3.2 Тесты должны быть изолированными
Каждый тест должен быть независим от других и не полагаться на результаты предыдущих тестов.

---

### 3.3 Использование фикстур
Фикстуры готовят среду для тестов (например, создают тестовые данные).

#### Пример фикстуры:
```python
import pytest

@pytest.fixture
def test_data():
    return {"name": "Test User", "age": 30}
```

---

### 3.4 Частота запуска тестов
- Модульные тесты запускаются при каждом изменении кода.
- Интеграционные и E2E-тесты могут запускаться по расписанию.

---

### 3.5 Поддерживаемость
Тесты должны быть:
- Легко читаемыми.
- Простыми в обновлении при изменении требований.


# Команды Linux

# Linux: Базовые команды

Linux — это операционная система с интерфейсом командной строки (CLI), где взаимодействие с системой происходит с помощью текстовых команд. Знание базовых команд позволяет эффективно работать с файлами, директориями, процессами, пользователями и сетью.

---

## 1. Работа с файлами и каталогами

### 1.1 Навигация по файловой системе
- `pwd` — показывает текущую директорию (путь).
  ```bash
  pwd
  ```

- `ls` — отображает содержимое директории.
  - `ls -l` — подробная информация (размер, права).
  - `ls -a` — отображает скрытые файлы.
  ```bash
  ls -la
  ```

- `cd <путь>` — переход в другую директорию.
  - `cd ..` — на уровень выше.
  - `cd ~` — в домашнюю директорию.
  ```bash
  cd /home/user/Documents
  ```

---

### 1.2 Создание и удаление
- `touch <имя файла>` — создаёт новый пустой файл.
  ```bash
  touch file.txt
  ```

- `mkdir <имя директории>` — создаёт новую директорию.
  ```bash
  mkdir my_folder
  ```

- `rm <имя файла>` — удаляет файл.
  - `rm -r <директория>` — удаляет директорию с её содержимым.
  ```bash
  rm file.txt
  rm -r my_folder
  ```

---

### 1.3 Копирование и перемещение
- `cp <источник> <назначение>` — копирует файл или директорию.
  - `cp -r` — копирует директорию.
  ```bash
  cp file.txt backup.txt
  cp -r folder1 folder2
  ```

- `mv <источник> <назначение>` — перемещает файл/директорию или переименовывает.
  ```bash
  mv file.txt new_file.txt
  mv folder1 /home/user/Documents
  ```

---

### 1.4 Просмотр содержимого
- `cat <имя файла>` — выводит содержимое файла.
  ```bash
  cat file.txt
  ```

- `less <имя файла>` — позволяет постранично просматривать файл.
  ```bash
  less large_file.txt
  ```

- `head -n <количество строк> <имя файла>` — выводит первые строки файла.
  ```bash
  head -n 10 file.txt
  ```

- `tail -n <количество строк> <имя файла>` — выводит последние строки файла.
  ```bash
  tail -n 10 file.txt
  ```

---

## 2. Работа с правами доступа

### 2.1 Проверка прав
- `ls -l` — отображает права доступа к файлам/директориям.
  ```bash
  ls -l
  ```

### 2.2 Изменение прав
- `chmod <права> <файл>` — изменяет права доступа.
  - `r` — чтение.
  - `w` — запись.
  - `x` — выполнение.
  ```bash
  chmod 755 script.sh
  ```

- `chown <пользователь>:<группа> <файл>` — изменяет владельца.
  ```bash
  chown user:group file.txt
  ```

---

## 3. Управление процессами

### 3.1 Запуск процессов
- `&` — запускает процесс в фоновом режиме.
  ```bash
  python3 script.py &
  ```

- `jobs` — отображает фоновые процессы.

### 3.2 Управление процессами
- `ps` — показывает список процессов текущего сеанса.
  ```bash
  ps
  ```

- `top` — отображает активные процессы в реальном времени.

- `kill <PID>` — завершает процесс по идентификатору.
  ```bash
  kill 1234
  ```

---

## 4. Управление пакетами

### 4.1 Ubuntu/Debian
- `apt update` — обновляет список пакетов.
- `apt install <пакет>` — устанавливает пакет.
- `apt remove <пакет>` — удаляет пакет.

```bash
sudo apt update
sudo apt install git
sudo apt remove git
```

### 4.2 CentOS/RedHat
- `yum update` — обновляет систему.
- `yum install <пакет>` — устанавливает пакет.

---

## 5. Работа с сетью

### 5.1 Проверка соединений
- `ping <адрес>` — проверяет доступность хоста.
  ```bash
  ping google.com
  ```

- `curl <адрес>` — отправляет HTTP-запрос и выводит ответ.
  ```bash
  curl http://example.com
  ```

### 5.2 Проверка конфигурации
- `ifconfig` — показывает настройки сетевых интерфейсов.
  ```bash
  ifconfig
  ```

- `netstat` — отображает сетевые соединения и порты.

---

## 6. Поиск и фильтрация

### 6.1 Поиск файлов
- `find <путь> -name <имя>` — ищет файл или директорию.
  ```bash
  find /home/user -name file.txt
  ```

### 6.2 Фильтрация вывода
- `grep <шаблон>` — ищет строки, содержащие шаблон.
  ```bash
  grep "ERROR" log.txt
  ```

- `sort` — сортирует строки.
  ```bash
  sort file.txt
  ```

- `wc` — считает количество строк, слов и символов.
  ```bash
  wc -l file.txt
  ```

---

## 7. Архивирование

- `tar -cvf <архив> <файл/папка>` — создаёт архив.
  ```bash
  tar -cvf archive.tar folder
  ```

- `tar -xvf <архив>` — извлекает архив.
  ```bash
  tar -xvf archive.tar
  ```

- `gzip <файл>` — сжимает файл.
  ```bash
  gzip file.txt
  ```

---